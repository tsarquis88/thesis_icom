\chapter{Código fuente del módulo decimador}

\begin{Verbatim}[frame=single]
/* Módulo en Verilog del decimador */

module decimator # 
(
  parameter IAGC_STATUS_SIZE  = 4,
  parameter DECIMATOR_SIZE    = 4
)
(
  input wire i_clock,
  input wire [IAGC_STATUS_SIZE-1:0] i_iagc_status,
  input wire i_gate,
  input wire [DECIMATOR_SIZE-1:0] i_decimator,
  output wire o_sample
);

  localparam IAGC_STATUS_RESET = 4'b0000;
  localparam IAGC_STATUS_INIT  = 4'b0001;

  integer                             counter;
  
  always@( posedge i_clock ) begin        
      
    if( i_iagc_status == IAGC_STATUS_RESET || 
        i_iagc_status == IAGC_STATUS_INIT  || 
        ~i_gate )
      counter <= 0;
    else
      counter <= counter >= i_decimator - 1 ? 
                 0 : counter + 1;
  end
  
  assign o_sample = counter == ( i_decimator - 1 );
    
endmodule
\end{Verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Código fuente del módulo detector de fase}

\begin{Verbatim}[frame=single]
/* Módulo en Verilog del detector de fase */

module phase_detector #
(
  parameter IAGC_STATUS_SIZE  = 4,
  parameter ZMOD_DATA_SIZE    = 14,
  parameter PHASE_COUNT_SIZE  = 16
)
(
  input wire i_clock,
  input wire i_sample,
  input wire [IAGC_STATUS_SIZE-1:0] i_iagc_status,
  input wire signed [ZMOD_DATA_SIZE-1:0] i_reference,
  input wire signed [ZMOD_DATA_SIZE-1:0] i_error,
  input wire [PHASE_COUNT_SIZE-1:0] i_phase_count,
  output wire o_in_phase
);

  localparam IAGC_STATUS_RESET    = 4'b0000;
  localparam IAGC_STATUS_INIT     = 4'b0001;
  
  localparam STATUS_SIZE      = 2;
  
  localparam STATUS_INIT      = 0;
  localparam STATUS_SAMPLE    = 1;
  localparam STATUS_DETECT    = 2;
  
  reg [STATUS_SIZE-1:0] status;           
  reg [STATUS_SIZE-1:0] next_status;
          
  integer phase_counter;
  integer no_phase_counter;
  integer samples;
  reg     in_phase;

  always@( posedge i_clock ) begin
      
    status <= i_iagc_status == IAGC_STATUS_RESET ? 
              STATUS_INIT : next_status;
    
    case( status )
        
      STATUS_INIT: begin
        phase_counter       <= 0;
        no_phase_counter    <= 0;
        samples             <= 0;
        in_phase            <= in_phase;
      end
        
      STATUS_SAMPLE: begin
        if( i_sample ) begin
          if( i_reference >= 0 && i_error >= 0 )
            phase_counter <= phase_counter + 1;
          else if( i_reference < 0 && i_error < 0 )
            phase_counter <= phase_counter + 1;
          else
            no_phase_counter <= no_phase_counter + 1;
              
          samples <= samples + 1;
        end
        else begin
          samples             <= samples;
          phase_counter       <= phase_counter;
          no_phase_counter    <= no_phase_counter;
        end
        
        in_phase            <= in_phase;
      end
        
      STATUS_DETECT: begin
        samples <= samples;
        phase_counter <= phase_counter;
        no_phase_counter <= no_phase_counter;
        in_phase <= phase_counter >= no_phase_counter;
      end
        
      default: begin 
        phase_counter       <= 0;
        no_phase_counter    <= 0;
        samples             <= 0;
        in_phase            <= 1'b0;
      end
        
    endcase
  end
  
  always@( * ) begin
    case( status )
      STATUS_INIT: next_status = i_iagc_status ==
                       IAGC_STATUS_RESET ? STATUS_INIT :
                       STATUS_SAMPLE;
      STATUS_SAMPLE: next_status = samples >= i_phase_count 
                       ? STATUS_DETECT : STATUS_SAMPLE;
      STATUS_DETECT: next_status = STATUS_INIT;
      default: next_status = STATUS_INIT;
    endcase
  end
  
  assign o_in_phase = in_phase;
    
endmodule
\end{Verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Código fuente del módulo detector de amplitud}

\begin{Verbatim}[frame=single]
/* Módulo en Verilog del detector de amplitud */

module amplitude_detector #
(
  parameter IAGC_STATUS_SIZE      = 4,
  parameter ZMOD_DATA_SIZE        = 14,
  parameter AMPLITUDE_DATA_SIZE   = 14,
  parameter AMPLITUDE_COUNT_SIZE  = 16
)
(
  input wire i_clock,
  input wire i_sample,
  input wire [IAGC_STATUS_SIZE-1:0] i_iagc_status,
  input wire signed [ZMOD_DATA_SIZE-1:0] i_reference,
  input wire signed [ZMOD_DATA_SIZE-1:0] i_error,
  input wire [AMPLITUDE_COUNT_SIZE-1:0] 
                                    i_amplitude_count,
  output wire [AMPLITUDE_DATA_SIZE-1:0] 
                                    o_reference_amplitude,
  output wire [AMPLITUDE_DATA_SIZE-1:0] 
                                    o_error_amplitude,
  output wire o_valid
);

  localparam IAGC_STATUS_RESET    = 4'b0000;
  localparam IAGC_STATUS_INIT     = 4'b0001;
  
  localparam STATUS_SIZE      = 2;
  
  localparam STATUS_INIT      = 0;
  localparam STATUS_SAMPLE    = 1;
  localparam STATUS_DETECT    = 2;
  localparam STATUS_VALID     = 3;
  
  reg [STATUS_SIZE-1:0] status;           
  reg [STATUS_SIZE-1:0] next_status;
  reg signed [ZMOD_DATA_SIZE-1:0] max_reference;
  reg signed [ZMOD_DATA_SIZE-1:0] max_error;
  reg [AMPLITUDE_DATA_SIZE-1:0] reference_amplitude;
  reg [AMPLITUDE_DATA_SIZE-1:0] error_amplitude;
          
  integer samples;
    
  always@( posedge i_clock ) begin
      
    status <= i_iagc_status == IAGC_STATUS_RESET ? 
                             STATUS_INIT : next_status;
    
    case( status )
        
      STATUS_INIT: begin
        max_reference <= { ZMOD_DATA_SIZE { 1'b0 } };
        max_error <= { ZMOD_DATA_SIZE { 1'b0 } };
        reference_amplitude <= reference_amplitude;
        error_amplitude <= error_amplitude;
        samples <= 0;
      end
      
      STATUS_SAMPLE: begin
        if( i_sample ) begin
          max_reference <= i_reference > max_reference ? 
                            i_reference : max_reference;
          max_error <= i_error > max_error ? 
                            i_error : max_error;
          reference_amplitude <= reference_amplitude;
          error_amplitude <= error_amplitude;
          samples <= samples + 1;
        end
        else begin
          max_reference <= max_reference;
          max_error <= max_error;
          reference_amplitude <= reference_amplitude;
          error_amplitude <= error_amplitude;
          samples <= samples;
        end
      end
      
      STATUS_DETECT: begin
        max_reference <= max_reference;
        max_error <= max_error;
        reference_amplitude <= max_reference;
        error_amplitude <= max_error;
        samples <= samples;
      end
      
      STATUS_VALID: begin
        max_reference <= max_reference;
        max_error <= max_error;
        reference_amplitude <= reference_amplitude;
        error_amplitude <= error_amplitude;
        samples <= samples;
      end
      
      default: begin 
        max_reference <= { ZMOD_DATA_SIZE { 1'b0 } };
        max_error <= { ZMOD_DATA_SIZE { 1'b0 } };
        reference_amplitude <= reference_amplitude;
        error_amplitude <= error_amplitude;
        samples <= 0;
      end
        
    endcase
  end
  
  always@( * ) begin
    case( status )
      STATUS_INIT: next_status = i_iagc_status ==
      IAGC_STATUS_RESET ? STATUS_INIT   : STATUS_SAMPLE;
      STATUS_SAMPLE: next_status = samples >= 
         i_amplitude_count ? STATUS_DETECT : STATUS_SAMPLE;
      STATUS_DETECT: next_status = STATUS_VALID;
      STATUS_VALID: next_status = STATUS_INIT;            
      default: next_status = STATUS_INIT;           
    endcase
  end
  
  assign o_reference_amplitude = reference_amplitude;
  assign o_error_amplitude = error_amplitude;
  assign o_valid = status == STATUS_VALID;
    
endmodule
\end{Verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Código fuente del módulo divisor}

\begin{Verbatim}[frame=single]
/* Módulo en Verilog del procesador(divisor) */

module processor #
(
  parameter AMPLITUDE_DATA_SIZE   = 13,
  parameter QUOTIENT_SIZE         = 8,
  parameter FRACTIONAL_SIZE       = 8
)
(
  input i_clock,
  input [AMPLITUDE_DATA_SIZE-1:0] i_reference,
  input [AMPLITUDE_DATA_SIZE-1:0] i_error,
  input i_valid,
  output [QUOTIENT_SIZE-1:0] o_quotient,
  output [FRACTIONAL_SIZE-1:0] o_fractional
);
    
  localparam DIV_RESULT_DATA_SIZE = 24;
  
  wire [DIV_RESULT_DATA_SIZE-1:0] div_result;
  wire div_valid;
  reg [QUOTIENT_SIZE-1:0] quotient;
  reg [FRACTIONAL_SIZE-1:0] fractional;
  
  always@( posedge i_clock ) begin
    quotient   <= div_valid ? 
                  div_result[15 : 8] : quotient;
    fractional <= div_valid ? 
                  div_result[7  : 0] : fractional;
  end
  
  assign o_quotient   = quotient;
  assign o_fractional = fractional;
  
  div_gen_0
  u_div_gen_0
  (
    .aclk                       ( i_clock       ),
    .s_axis_dividend_tvalid     ( i_valid       ),
    .s_axis_dividend_tdata      ( i_error       ),
    .s_axis_divisor_tvalid      ( i_valid       ),
    .s_axis_divisor_tdata       ( i_reference   ),
    .m_axis_dout_tvalid         ( div_valid     ),
    .m_axis_dout_tdata          ( div_result    )
  );

endmodule
\end{Verbatim}
